{"response": "# Model:\n```python\nfrom pytm import TM, Boundary, Server, Client, DataStore, DataFlow, ExternalEntity\n\ntm = TM(\"OAuth 2.0 Authorization Code Flow\")\n\n# Boundaries\ninternet = Boundary(\"Internet Boundary\")\nclient_boundary = Boundary(\"Client Boundary\")\nauth_boundary = Boundary(\"Authorization Server Boundary\")\nresource_boundary = Boundary(\"Resource Server Boundary\")\n\n# Components\nuser = ExternalEntity(\"User\", boundary=internet)\nclient = Client(\"Client Application\", boundary=client_boundary)\nauth_server = Server(\"Authorization Server\", boundary=auth_boundary)\nresource_server = Server(\"Resource Server\", boundary=resource_boundary)\ntoken_store = DataStore(\"Token Store\", boundary=auth_boundary)\nresource_db = DataStore(\"Resource DB\", boundary=resource_boundary)\n\n# Dataflows\nDataFlow(user, client, \"Initiate Authorization Request\", boundary0=internet, boundary1=client_boundary)\nDataFlow(client, auth_server, \"GET /authorize?response_type=code&client_id&redirect_uri&scope&state\", boundary0=client_boundary, boundary1=auth_boundary)\nDataFlow(auth_server, user, \"Login Page & Consent\", boundary0=auth_boundary, boundary1=internet)\nDataFlow(user, auth_server, \"Submit Credentials & Consent\", boundary0=internet, boundary1=auth_boundary)\nDataFlow(auth_server, client, \"Redirect with Authorization Code (code & state)\", boundary0=auth_boundary, boundary1=client_boundary)\nDataFlow(client, auth_server, \"POST /token (grant_type=authorization_code, code, client_id, client_secret)\", boundary0=client_boundary, boundary1=auth_boundary)\nDataFlow(auth_server, client, \"Access Token Response (access_token, refresh_token)\", boundary0=auth_boundary, boundary1=client_boundary)\nDataFlow(auth_server, token_store, \"Store Refresh Token\", boundary0=auth_boundary, boundary1=auth_boundary)\nDataFlow(client, resource_server, \"GET /resource Authorization: Bearer access_token\", boundary0=client_boundary, boundary1=resource_boundary)\nDataFlow(resource_server, resource_db, \"Read Protected Resource\", boundary0=resource_boundary, boundary1=resource_boundary)\nDataFlow(resource_server, client, \"Return Protected Resource\", boundary0=resource_boundary, boundary1=client_boundary)\n\ntm.process()\n```\n\n# Threats\nSpoofing:\n- Client Impersonation: An attacker registers or spoofs a legitimate client_id to receive authorization codes and tokens.\n- Resource Owner Impersonation: Attacker steals or guesses user credentials at the authorization server login.\n- Authorization Server Spoofing: Fake auth server captures credentials and authorization codes via malicious redirect.\n- Resource Server Spoofing: Malicious endpoint impersonates the resource server to capture bearer tokens.\n- User Agent Spoofing: An attacker forges browser headers or User-Agent to bypass client\u2011side checks.\n\nTampering:\n- Authorization Code Tampering: Modify the code parameter in the redirect URI to intercept or misroute authorization.\n- State Parameter Tampering: Alter or remove the state value to perform CSRF or hijack the callback.\n- Access Token Modification: Intercept and modify bearer tokens in transit to gain unauthorized access.\n- Request Parameter Tampering: Change grant_type, redirect_uri or scope parameters to bypass server validation.\n- Token Store Tampering: Unauthorized modification or deletion of tokens in the authorization server\u2019s datastore.\n\nRepudiation:\n- Missing Audit Logs: Lack of detailed logs at the auth or resource servers prevents proving who requested or used tokens.\n- Consent Repudiation: User or client denies having granted consent; no signed proof prevents dispute resolution.\n- Code Exchange Repudiation: Client denies having exchanged the authorization code for tokens; absence of proof hinders accountability.\n- Token Usage Repudiation: Resource server lacks logging of which token accessed which resource and when.\n\nInformation Disclosure:\n- Authorization Code in URL: Codes in query parameters can leak via browser history, referrer logs, or proxy logs.\n- Access Token Leakage via Referrer: Misconfigured endpoints include bearer tokens in referrer headers.\n- Client Secret Exposure: Insecure storage or transmission of client_secret in client\u2011side apps or logs.\n- Insecure Transport (HTTP): Credentials, codes, and tokens exposed in plaintext if HTTPS is not enforced.\n- Token Storage Leakage: Insecure token storage on client devices (e.g., localStorage) allows local attackers to steal them.\n\nDenial of Service:\n- Authorization Endpoint Flooding: High volumes of /authorize requests exhaust auth server resources or trigger rate limits.\n- Token Endpoint Abuse: Repeated invalid token exchange attempts consume CPU and database I/O at the auth server.\n- Resource Server Overload: Flooding resource requests (with valid or invalid tokens) exhausts server or database.\n- Code Replay Lockout: Replaying valid authorization codes triggers repeated validation and may lock out legitimate flows.\n\nElevation of Privilege:\n- Scope Manipulation: Attacker requests extra scopes in /authorize and the server fails to validate against registered scopes.\n- Refresh Token Abuse: Stolen refresh tokens used to obtain long\u2011lived access tokens and access unauthorized resources.\n- Open Redirect Exploitation: Malicious actors exploit weak redirect_uri validation to escalate privileges or phish tokens.\n- Token Forgery via Weak Signing: Exploit weak or absent signature algorithms to craft tokens with elevated privileges.", "model": "\nfrom pytm import TM, Boundary, Server, Client, DataStore, DataFlow, ExternalEntity\n\ntm = TM(\"OAuth 2.0 Authorization Code Flow\")\n\n# Boundaries\ninternet = Boundary(\"Internet Boundary\")\nclient_boundary = Boundary(\"Client Boundary\")\nauth_boundary = Boundary(\"Authorization Server Boundary\")\nresource_boundary = Boundary(\"Resource Server Boundary\")\n\n# Components\nuser = ExternalEntity(\"User\", boundary=internet)\nclient = Client(\"Client Application\", boundary=client_boundary)\nauth_server = Server(\"Authorization Server\", boundary=auth_boundary)\nresource_server = Server(\"Resource Server\", boundary=resource_boundary)\ntoken_store = DataStore(\"Token Store\", boundary=auth_boundary)\nresource_db = DataStore(\"Resource DB\", boundary=resource_boundary)\n\n# Dataflows\nDataFlow(user, client, \"Initiate Authorization Request\", boundary0=internet, boundary1=client_boundary)\nDataFlow(client, auth_server, \"GET /authorize?response_type=code&client_id&redirect_uri&scope&state\", boundary0=client_boundary, boundary1=auth_boundary)\nDataFlow(auth_server, user, \"Login Page & Consent\", boundary0=auth_boundary, boundary1=internet)\nDataFlow(user, auth_server, \"Submit Credentials & Consent\", boundary0=internet, boundary1=auth_boundary)\nDataFlow(auth_server, client, \"Redirect with Authorization Code (code & state)\", boundary0=auth_boundary, boundary1=client_boundary)\nDataFlow(client, auth_server, \"POST /token (grant_type=authorization_code, code, client_id, client_secret)\", boundary0=client_boundary, boundary1=auth_boundary)\nDataFlow(auth_server, client, \"Access Token Response (access_token, refresh_token)\", boundary0=auth_boundary, boundary1=client_boundary)\nDataFlow(auth_server, token_store, \"Store Refresh Token\", boundary0=auth_boundary, boundary1=auth_boundary)\nDataFlow(client, resource_server, \"GET /resource Authorization: Bearer access_token\", boundary0=client_boundary, boundary1=resource_boundary)\nDataFlow(resource_server, resource_db, \"Read Protected Resource\", boundary0=resource_boundary, boundary1=resource_boundary)\nDataFlow(resource_server, client, \"Return Protected Resource\", boundary0=resource_boundary, boundary1=client_boundary)\n\ntm.process()", "threats": "# Threats\nSpoofing:\n- Client Impersonation: An attacker registers or spoofs a legitimate client_id to receive authorization codes and tokens.\n- Resource Owner Impersonation: Attacker steals or guesses user credentials at the authorization server login.\n- Authorization Server Spoofing: Fake auth server captures credentials and authorization codes via malicious redirect.\n- Resource Server Spoofing: Malicious endpoint impersonates the resource server to capture bearer tokens.\n- User Agent Spoofing: An attacker forges browser headers or User-Agent to bypass client\u2011side checks.\n\nTampering:\n- Authorization Code Tampering: Modify the code parameter in the redirect URI to intercept or misroute authorization.\n- State Parameter Tampering: Alter or remove the state value to perform CSRF or hijack the callback.\n- Access Token Modification: Intercept and modify bearer tokens in transit to gain unauthorized access.\n- Request Parameter Tampering: Change grant_type, redirect_uri or scope parameters to bypass server validation.\n- Token Store Tampering: Unauthorized modification or deletion of tokens in the authorization server\u2019s datastore.\n\nRepudiation:\n- Missing Audit Logs: Lack of detailed logs at the auth or resource servers prevents proving who requested or used tokens.\n- Consent Repudiation: User or client denies having granted consent; no signed proof prevents dispute resolution.\n- Code Exchange Repudiation: Client denies having exchanged the authorization code for tokens; absence of proof hinders accountability.\n- Token Usage Repudiation: Resource server lacks logging of which token accessed which resource and when.\n\nInformation Disclosure:\n- Authorization Code in URL: Codes in query parameters can leak via browser history, referrer logs, or proxy logs.\n- Access Token Leakage via Referrer: Misconfigured endpoints include bearer tokens in referrer headers.\n- Client Secret Exposure: Insecure storage or transmission of client_secret in client\u2011side apps or logs.\n- Insecure Transport (HTTP): Credentials, codes, and tokens exposed in plaintext if HTTPS is not enforced.\n- Token Storage Leakage: Insecure token storage on client devices (e.g., localStorage) allows local attackers to steal them.\n\nDenial of Service:\n- Authorization Endpoint Flooding: High volumes of /authorize requests exhaust auth server resources or trigger rate limits.\n- Token Endpoint Abuse: Repeated invalid token exchange attempts consume CPU and database I/O at the auth server.\n- Resource Server Overload: Flooding resource requests (with valid or invalid tokens) exhausts server or database.\n- Code Replay Lockout: Replaying valid authorization codes triggers repeated validation and may lock out legitimate flows.\n\nElevation of Privilege:\n- Scope Manipulation: Attacker requests extra scopes in /authorize and the server fails to validate against registered scopes.\n- Refresh Token Abuse: Stolen refresh tokens used to obtain long\u2011lived access tokens and access unauthorized resources.\n- Open Redirect Exploitation: Malicious actors exploit weak redirect_uri validation to escalate privileges or phish tokens.\n- Token Forgery via Weak Signing: Exploit weak or absent signature algorithms to craft tokens with elevated privileges."}